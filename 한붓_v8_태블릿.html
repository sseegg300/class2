<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover">
<title>나도 오일러처럼 - 태블릿 전용</title>
<style>
  :root{
    --bg:#0f1220;
    --text:#0b0d1a;
    --light:#ffffff;
    --muted:#475569;
    --menu-grad: linear-gradient(90deg, #62b3ff 0%, #8a7bff 50%, #a05eff 100%);
    --menu-inner: linear-gradient(180deg, rgba(255,255,255,.65), rgba(255,255,255,.35));
    --btn-gray: linear-gradient(180deg, #6b7a85, #4e5a64);
    --btn-blue: linear-gradient(180deg, #0eb0ff, #0076ff);
    --badge-bg: rgba(255,255,255,.28);
    --panel: rgba(255,255,255,.06);
    --shadow: 0 10px 30px rgba(0,0,0,.35);
    --radius: 16px;
  }

  *{ box-sizing:border-box; }
  html,body{ height:100%; }
  body{
    margin:0;
    padding: 10px 12px calc(env(safe-area-inset-bottom,0) + 12px);
    background: radial-gradient(1200px 900px at 30% -10%, #1a2142 0%, #0f1220 50%, #0b0d1a 100%);
    color:#e9edf5;
    font: 16px/1.6 system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans KR", sans-serif;
    overscroll-behavior: none;
  }

  .app{ max-width: 1100px; margin: 0 auto; }

  /* ====== 상단 메뉴(첨부 스타일) ====== */
  .menubar{
    display:flex; align-items:center; gap:14px;
    padding: 8px;
    border-radius: 18px;
    background: var(--menu-grad);
    box-shadow: var(--shadow);
    position: relative;
  }
  .menubar-inner{
    display:flex; align-items:center; gap:14px;
    width:100%;
    padding: 10px 12px;
    border-radius: 14px;
    background: var(--menu-inner);
    color: #0b1020;
  }
  .left-pack{
    display:flex; align-items:center; gap:10px;
    padding:6px 10px;
    border-radius: 999px;
    background: var(--badge-bg);
    color:#1f2937;
    font-weight:700;
    white-space:nowrap;
  }
  .dot{ width:6px; height:6px; border-radius:50%; background:#0ea5ff; box-shadow:0 0 10px #0ea5ff; }

  .progress{
    width:150px; height:10px; border-radius:999px;
    background: rgba(255,255,255,.6); overflow:hidden;
  }
  .bar{ height:100%; width:0%; background: linear-gradient(90deg, #85d0ff, #d9e7ff); transition: width .2s ease; }

  .title{
    flex:1; text-align:center;
    letter-spacing: .4rem;  /* 첨부 이미지처럼 자간 넓게 */
    font-weight:800; color:#0b0d1a;
  }

  .menu-buttons{ display:flex; gap:10px; }
  .btn{
    border:0; cursor:pointer; border-radius:12px;
    color:#fff; padding:10px 14px; font-weight:800;
    box-shadow: inset 0 1px 0 rgba(255,255,255,.25), 0 4px 10px rgba(0,0,0,.15);
  }
  .btn:active{ transform: translateY(1px); }
  .btn.gray{ background: var(--btn-gray); }
  .btn.blue{ background: var(--btn-blue); }

  /* ====== 스테이지 ====== */
  .stage{
    margin-top: 12px;
    background: var(--panel);
    border-radius: 16px;
    padding: 10px;
    box-shadow: var(--shadow);
    display:flex; justify-content:center;
  }
  canvas{
    display:block;
    background: linear-gradient(180deg, rgba(255,255,255,.18), rgba(255,255,255,.08));
    border-radius: 16px;
    touch-action: none; /* 터치 스크롤 방지 */
    /* width/height는 JS에서 정확한 px로 설정(정사각형) */
    max-width: 100%;
  }

  /* 승리 오버레이 */
  .overlay{
    position: fixed; inset:0; display:none;
    align-items:center; justify-content:center;
    background: rgba(0,0,0,.45); z-index: 10;
  }
  .overlay .modal{
    width:min(92vw, 460px);
    background: linear-gradient(180deg, rgba(255,255,255,.2), rgba(255,255,255,.08));
    border-radius:18px; box-shadow: var(--shadow);
    padding:18px; color:#e9edf5;
  }
  .modal h2{ margin:0 0 8px 0; }
  .modal p{ margin:0 0 12px 0; color:#c9d2e3; }
  .modal .row{ display:flex; gap:8px; flex-wrap:wrap; }
</style>
</head>
<body>
<div class="app">
  <!-- 상단 메뉴바 -->
  <div class="menubar">
    <div class="menubar-inner" id="menubarInner">
      <div class="left-pack" aria-live="polite">
        <span>레벨&nbsp;<span id="levelLabel">1</span></span>
        <span class="dot" aria-hidden="true"></span>
        <span>간선&nbsp;<span id="visCount">0</span>&nbsp;/&nbsp;<span id="edgeCount">0</span></span>
        <div class="progress"><div class="bar" id="bar"></div></div>
      </div>
      <div class="title">나도&nbsp;&nbsp;오일러처럼</div>
      <div class="menu-buttons">
        <button class="btn gray" id="sameBtn">초기화</button>
        <button class="btn blue" id="nextBtn">다음 단계</button>
      </div>
    </div>
  </div>

  <!-- 게임 스테이지 -->
  <div class="stage">
    <canvas id="board" aria-label="그래프 퍼즐 캔버스"></canvas>
  </div>
</div>

<!-- 승리 모달 -->
<div class="overlay" id="overlay" role="dialog" aria-modal="true" aria-labelledby="winTitle">
  <div class="modal">
    <h2 id="winTitle">성공! 🎉</h2>
    <p>모든 간선을 정확히 한 번씩 지났어요.</p>
    <div class="row">
      <button class="btn gray" id="replayBtn">같은 레벨 다시</button>
      <button class="btn blue" id="goNextBtn">다음 단계 ▶</button>
    </div>
  </div>
</div>

<script>
(()=>{
  const canvas = document.getElementById('board');
  const ctx = canvas.getContext('2d');

  // 메뉴/표시 요소
  const levelLabel = document.getElementById('levelLabel');
  const visCountEl = document.getElementById('visCount');
  const edgeCountEl = document.getElementById('edgeCount');
  const barEl = document.getElementById('bar');

  const menubarInner = document.getElementById('menubarInner');

  // 버튼
  const sameBtn  = document.getElementById('sameBtn');   // 초기화(같은 퍼즐)
  const nextBtn  = document.getElementById('nextBtn');   // 다음 단계
  const overlay  = document.getElementById('overlay');
  const replayBtn= document.getElementById('replayBtn');
  const goNextBtn= document.getElementById('goNextBtn');

  // 상태
  let level = 1;
  let nodes = [];      // [{x,y}]
  let edges = [];      // [{a,b, visited:false}]
  let used = new Set();// key "a-b" with a<b
  let current = null;  // 현재 정점 index
  let visitedCount = 0;
  let nodeR = 10;      // 크기 반응형
  let prevCssSize = null; // 정사각 캔버스 CSS px (좌표 스케일 기준)

  // ===== 유틸 =====
  const key = (a,b)=> a<b ? `${a}-${b}` : `${b}-${a}`;
  const hasEdge = (a,b)=> used.has(key(a,b));
  const addEdge = (a,b)=>{ if(a===b || hasEdge(a,b)) return false; used.add(key(a,b)); edges.push({a,b,visited:false}); return true; };
  const neighbors = (i)=> edges.reduce((arr,e)=>{ if(e.a===i) arr.push([e.b, e]); else if(e.b===i) arr.push([e.a, e]); return arr;}, []);

  // ===== 레이아웃(태블릿 최적 크기 계산) =====
  function layoutCanvasSquare(){
    // 1) 메뉴바 실제 높이 측정
    const headerH = menubarInner.getBoundingClientRect().height + 16 /* menubar padding 여유 */;
    // 2) 뷰포트 가용 높이 계산 (세로/가로 모두 대응)
    const vh = window.innerHeight;
    const availH = Math.max(200, vh - headerH - 20); // 하단 여백
    // 3) 가로 폭은 컨테이너 폭
    const containerW = document.querySelector('.stage').getBoundingClientRect().width;
    // 4) 정사각형 한 변(px)
    const size = Math.floor(Math.min(containerW, availH));
    // 5) CSS 실제 픽셀 적용
    canvas.style.width = size + 'px';
    canvas.style.height = size + 'px';

    // 좌표 스케일 갱신을 위해 prevCssSize와 비교
    if(prevCssSize === null) prevCssSize = size;
    else if(size !== prevCssSize){
      const s = size / prevCssSize;
      if(isFinite(s) && s > 0){
        for(const p of nodes){ p.x *= s; p.y *= s; }
        prevCssSize = size;
      }
    }else{
      prevCssSize = size;
    }

    fitCanvasForDPR();
    nodeR = Math.max(7, Math.min(16, Math.round(size / 36)));
  }

  function fitCanvasForDPR(){
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const rect = canvas.getBoundingClientRect(); // CSS px
    canvas.width  = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }

  // ===== 그래프/퍼즐 생성 =====
  function placeNodes(n){
    const rect = canvas.getBoundingClientRect();
    const cx = rect.width/2, cy = rect.height/2;
    const r = Math.min(rect.width, rect.height) * 0.40;
    nodes = [];
    for(let i=0;i<n;i++){
      const t = (Math.PI*2) * (i/n) - Math.PI/2; // 위쪽부터 시계방향
      nodes.push({ x: cx + r*Math.cos(t), y: cy + r*Math.sin(t) });
    }
    prevCssSize = rect.width; // 현재 정사각 한 변
  }

  function makeEulerGraph(n){
    edges = []; used.clear(); current = null; visitedCount = 0;

    // 1) 기본 사이클
    for(let i=0;i<n;i++) addEdge(i, (i+1)%n);

    // 2) 난이도: chord 몇 개 추가(짝수 개)
    const chordPairs = Math.min( Math.floor(n/3), 3 + Math.floor(level/2) );
    let tries = 0, added=0;
    while(added < chordPairs*2 && tries < 400){
      tries++;
      const a = Math.floor(Math.random()*n);
      let b = Math.floor(Math.random()*n);
      if(a===b) continue;
      if(hasEdge(a,b)) continue;
      if((a+1)%n===b || (b+1)%n===a) continue; // 인접은 패스
      if(addEdge(a,b)) added++;
    }

    // 3) 50% 확률로 홀수 정점 2개(경로) 만들기
    if(Math.random() < 0.5){
      let count=0;
      while(count<200){
        count++;
        const a = Math.floor(Math.random()*n);
        let b = Math.floor(Math.random()*n);
        if(a===b) continue;
        if(hasEdge(a,b)) continue;
        if(addEdge(a,b)) break;
      }
    }

    // UI 반영
    edgeCountEl.textContent = String(edges.length);
    setProgress(0);
  }

  // ===== 진행/그리기 =====
  function setProgress(k){
    visitedCount = k;
    visCountEl.textContent = String(visitedCount);
    const p = edges.length ? Math.round((visitedCount/edges.length)*100) : 0;
    barEl.style.width = p + "%";
  }

  function draw(){
    const rect = canvas.getBoundingClientRect();
    ctx.clearRect(0,0,rect.width,rect.height);

    // 은은한 격자
    ctx.save();
    ctx.globalAlpha = 0.08;
    ctx.beginPath();
    const step = Math.max(24, Math.round(rect.width/14));
    for(let x=step; x<rect.width; x+=step){ ctx.moveTo(x,0); ctx.lineTo(x,rect.height); }
    for(let y=step; y<rect.height; y+=step){ ctx.moveTo(0,y); ctx.lineTo(rect.width,y); }
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 1;
    ctx.stroke();
    ctx.restore();

    // 간선
    ctx.lineCap='round';
    for(const e of edges){
      const a=nodes[e.a], b=nodes[e.b];
      ctx.beginPath();
      ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y);
      ctx.lineWidth = e.visited ? Math.max(3, nodeR*0.95) : Math.max(2, nodeR*0.7);
      ctx.strokeStyle = e.visited ? '#3aa3ff' : 'rgba(255,255,255,0.45)';
      ctx.stroke();
    }

    // 허용 이웃 하이라이트
    let allow = new Set();
    if(current!=null){
      for(const [nb, e] of neighbors(current)){ if(!e.visited) allow.add(nb); }
    }

    // 노드
    for(let i=0;i<nodes.length;i++){
      const p = nodes[i];
      const isCur = (i===current);
      const isAllow = allow.has(i);
      ctx.beginPath();
      ctx.arc(p.x,p.y, nodeR+6, 0, Math.PI*2);
      ctx.fillStyle = isCur ? 'rgba(90,162,255,0.25)' : (isAllow ? 'rgba(77,226,176,0.22)' : 'transparent');
      ctx.fill();

      ctx.beginPath();
      ctx.arc(p.x,p.y, nodeR, 0, Math.PI*2);
      ctx.fillStyle = isCur ? '#66e27a' : (isAllow ? '#4de2b0' : '#ffffff');
      ctx.fill();
      ctx.lineWidth = 1.2; ctx.strokeStyle='rgba(0,0,0,0.35)'; ctx.stroke();

      ctx.font = `bold ${Math.max(10, nodeR*0.9)}px system-ui, sans-serif`;
      ctx.fillStyle = isCur ? '#0a2b21' : '#0b0d1a';
      ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(String(i+1), p.x, p.y+0.5);
    }
  }

  // ===== 입력 처리 =====
  function getPointerPos(evt){
    const rect = canvas.getBoundingClientRect();
    let x,y;
    if(evt.touches && evt.touches.length){
      x = evt.touches[0].clientX - rect.left;
      y = evt.touches[0].clientY - rect.top;
    }else{
      x = evt.clientX - rect.left;
      y = evt.clientY - rect.top;
    }
    return {x,y};
  }
  function findNodeAt(x,y){
    const r = nodeR * 1.5;
    for(let i=0;i<nodes.length;i++){
      const p = nodes[i];
      const dx=x-p.x, dy=y-p.y;
      if(dx*dx + dy*dy <= r*r) return i;
    }
    return -1;
  }
  function onPointer(evt){
    evt.preventDefault();
    const {x,y} = getPointerPos(evt);
    const i = findNodeAt(x,y);
    if(i>=0) tryMove(i);
  }
  canvas.addEventListener('pointerdown', onPointer, {passive:false});
  canvas.addEventListener('click', onPointer, {passive:false});

  function shake(el){
    el.style.transition='transform .08s ease';
    el.style.transform='translateX(-5px)';
    setTimeout(()=>{ el.style.transform='translateX(5px)'; }, 90);
    setTimeout(()=>{ el.style.transform='translateX(0)'; el.style.transition=''; }, 180);
  }

  function tryMove(to){
    if(current===null){
      current = to; draw(); return;
    }
    if(current===to) return;

    let found = null;
    for(const e of edges){
      if(e.visited) continue;
      if( (e.a===current && e.b===to) || (e.b===current && e.a===to) ){ found = e; break; }
    }
    if(!found){ shake(canvas.parentElement); return; }

    found.visited = true;
    setProgress(visitedCount+1);
    current = to; draw();

    if(visitedCount === edges.length){
      setTimeout(()=> overlay.style.display='flex', 120);
    }
  }

  // ===== 컨트롤 =====
  sameBtn.addEventListener('click', ()=>{
    for(const e of edges) e.visited=false; // 같은 퍼즐 초기화
    setProgress(0); current=null; draw();
  });
  nextBtn.addEventListener('click', ()=>{
    level++; build(level);
  });
  replayBtn.addEventListener('click', ()=>{
    overlay.style.display='none'; build(level);
  });
  goNextBtn.addEventListener('click', ()=>{
    overlay.style.display='none'; level++; build(level);
  });

  // ===== 빌드 & 리사이즈 =====
  function build(lv){
    levelLabel.textContent = String(lv);
    layoutCanvasSquare();      // 먼저 정사각 크기 확정
    const n = Math.max(6, Math.min(14, 6 + Math.floor((lv-1)%9))); // 6~14
    placeNodes(n);
    makeEulerGraph(n);
    current=null; draw();
  }

  function onResize(){
    // 정사각 CSS 크기 재계산 + 좌표 비례 스케일 + DPR 재설정 + 다시 그리기
    layoutCanvasSquare();
    draw();
  }

  window.addEventListener('resize', onResize);
  window.addEventListener('orientationchange', onResize);

  // 시작
  build(level);

})();
</script>
</body>
</html>
