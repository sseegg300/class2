<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>나도 오일러처럼</title>
<style>
  :root{
    --bg1:#0ea5e9; --bg2:#7c3aed; --bg3:#22d3ee;
    --panel:rgba(255,255,255,.22); --panelBorder:rgba(255,255,255,.35);
    --ink:#0b2239; --muted:#5b7083;
    --edge:#d6dee6; --active:#2563eb; --node:#0f172a; --nodeSel:#f59e0b;
    --btn:#0ea5e9; --btnText:#fff; --btn2:#94a3b8;
    --shadow:0 18px 36px rgba(0,0,0,.18);
    --glassBlur:10px;
  }
  .dark{
    --panel:rgba(17,25,40,.55); --panelBorder:rgba(255,255,255,.18);
    --ink:#e2e8f0; --muted:#94a3b8;
    --edge:#4b5563; --active:#60a5fa; --node:#e5e7eb; --nodeSel:#f59e0b;
    --btn:#2563eb; --btnText:#fff; --btn2:#64748b;
    --shadow:0 20px 50px rgba(0,0,0,.4);
  }

  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; font-family:ui-sans-serif,system-ui,Segoe UI,Arial;
    color:var(--ink); display:flex; align-items:flex-start; justify-content:center; overflow-x:hidden;
    background: linear-gradient(135deg, var(--bg1), var(--bg2) 60%, var(--bg3));
    background-attachment: fixed;
  }

  .app{ width:min(900px,96vw); margin:18px auto; }

  .superbar{
    position:sticky; top:10px; z-index:10;
    display:grid; grid-template-columns:1fr auto 1fr; align-items:center; gap:10px;
    padding:12px 14px; border-radius:18px;
    background:linear-gradient(180deg, rgba(255,255,255,.65), rgba(255,255,255,.4));
    backdrop-filter:blur(var(--glassBlur)); border:1px solid var(--panelBorder);
    box-shadow:var(--shadow);
  }
  .sb-left{display:flex; align-items:center; gap:10px; flex-wrap:wrap}
  .stat{font-weight:800; font-size:14px}
  .dot{width:6px; height:6px; border-radius:999px; background:#9ca3af; opacity:.8}
  .mini{
    display:flex; align-items:center; gap:8px; font-weight:800; font-size:13px;
    padding:6px 10px; border-radius:999px; background:rgba(255,255,255,.6); border:1px solid var(--panelBorder);
  }
  .miniProgress{ width:120px; height:8px; border-radius:999px; overflow:hidden; background:rgba(0,0,0,.08); }
  .miniProgress > div{ height:100%; width:0%; background:linear-gradient(90deg,#22d3ee,#60a5fa,#a78bfa); transition:width .25s ease; }

  .sb-title{
    text-align:center; margin:0; line-height:1;
    font-size:clamp(18px,4.6vw,28px); letter-spacing:.18em;
    background:linear-gradient(90deg,#0f172a,#334155);
    -webkit-background-clip:text; background-clip:text; color:transparent;
    text-shadow:0 1px 14px rgba(0,0,0,.08);
    white-space:nowrap;
  }

  .sb-right{justify-self:end; display:flex; gap:8px; flex-wrap:wrap}
  .pill{
    all:unset; cursor:pointer; padding:10px 14px; border-radius:12px; font-weight:900; color:var(--btnText);
    background:linear-gradient(180deg, var(--btn), #0b84c5); box-shadow:0 10px 24px rgba(0,0,0,.18);
    transition:transform .08s ease, filter .2s ease;
  }
  .pill:hover{ filter:brightness(1.05) } .pill:active{ transform:translateY(1px) }
  .pill.secondary{ background:linear-gradient(180deg,var(--btn2),#4b5563) }

  .card{
    margin-top:14px; position:relative; padding:14px; border-radius:22px; backdrop-filter:blur(var(--glassBlur));
    background:var(--panel); border:1px solid var(--panelBorder); box-shadow:var(--shadow);
  }
  .progress{ position:relative; height:10px; background:rgba(255,255,255,.5); border-radius:999px; overflow:hidden; border:1px solid var(--panelBorder); margin-bottom:10px;}
  .progress > div{ height:100%; width:0%; background:linear-gradient(90deg,#22d3ee,#60a5fa,#a78bfa); transition:width .25s ease; }

  /* (표시 크기는 JS에서 동적으로 지정) */
  canvas{display:block; width:100%; height:auto; border-radius:16px; background:linear-gradient(180deg, rgba(255,255,255,.25), rgba(255,255,255,.12));}
  .helper{margin-top:10px; text-align:center; font-weight:700; color:var(--muted)}

  .overlay{position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(2,6,23,.45); backdrop-filter:blur(6px); }
  .modal{ width:min(480px,92vw); background:linear-gradient(180deg, rgba(255,255,255,.92), rgba(255,255,255,.85));
    border:1px solid rgba(255,255,255,.8); border-radius:20px; padding:24px; text-align:center; box-shadow:var(--shadow); }
  .modal h2{margin:0 0 6px; font-size:26px}
  .modal p{margin:0 0 16px; color:#334155}
  .row{display:flex; gap:10px; justify-content:center}

  .shake{animation:shake .25s linear}
  @keyframes shake{0%,100%{transform:translateX(0)}25%{transform:translateX(-6px)}75%{transform:translateX(6px)}}

  .canvasBrand{
    position:absolute; right:16px; bottom:14px; pointer-events:none;
    padding:6px 10px; border-radius:999px; font-weight:900; font-size:12px; letter-spacing:.02em;
    backdrop-filter:blur(8px);
    background:rgba(255,255,255,.55); border:1px solid var(--panelBorder); color:var(--ink);
    box-shadow:var(--shadow);
  }
</style>
</head>
<body>
  <div class="app">
    <div class="superbar">
      <div class="sb-left">
        <span class="stat">레벨 <b id="hdrLevel">1</b></span>
        <span class="dot"></span>
        <span class="mini">
          간선 <b id="hdrEdges">0</b>/<span id="hdrTotal">0</span>
          <span class="miniProgress" aria-hidden="true"><div id="hdrBar"></div></span>
        </span>
      </div>

      <h1 class="sb-title">나도 오일러처럼</h1>

      <div class="sb-right">
        <button id="reset" class="pill secondary">초기화</button>
        <button id="next"  class="pill">다음 단계</button>
      </div>
    </div>

    <div class="card">
      <div class="progress" aria-label="진행률"><div id="bar"></div></div>
      <canvas id="canvas"></canvas>
      <div class="canvasBrand" aria-hidden="true">by&nbsp;LucyA</div>
      <div id="msg" class="helper">아무 점이나 눌러 시작하세요!</div>
    </div>
  </div>

  <div class="overlay" id="overlay" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true">
      <h2>🎉 성공!</h2>
      <p>모든 간선을 한 번씩 지나 한붓그리기에 성공했어요.</p>
      <div class="row">
        <button id="retry" class="pill secondary">다시하기</button>
        <button id="goNext" class="pill">다음 단계 ▶</button>
      </div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d', { alpha: true });

  const elMsg = document.getElementById('msg');
  const bar = document.getElementById('bar');
  const hdrLevel = document.getElementById('hdrLevel');
  const hdrEdges = document.getElementById('hdrEdges');
  const hdrTotal = document.getElementById('hdrTotal');
  const hdrBar   = document.getElementById('hdrBar');
  const btnReset = document.getElementById('reset');
  const btnNext  = document.getElementById('next');
  const overlay  = document.getElementById('overlay');
  const btnRetry = document.getElementById('retry');
  const btnGoNext= document.getElementById('goNext');

  // 상태
  let level = 1, nodes=[], edges=[], edgeIndexMap=new Map(), visited=new Set(), currentNode=null;

  // ✅ 사이즈 계산(가로·세로 동시 고려)
  function fitCanvas(){
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

    // 카드 가로폭과 화면 높이(상단바/여백 제외) 중 작은 값으로 정사각형 크기 산정
    const cardRect = canvas.parentElement.getBoundingClientRect();
    const superbar = document.querySelector('.superbar');
    const reserved = (superbar?.getBoundingClientRect().height || 64) + 180; // 상단바 + 안내문 + 패딩

    const maxByWidth  = cardRect.width;
    const maxByHeight = window.innerHeight - reserved;
    const displaySize = Math.max(260, Math.floor(Math.min(maxByWidth, maxByHeight)));

    // CSS 표시 크기 고정(정사각형) → 도형도 함께 축소
    canvas.style.width  = displaySize + 'px';
    canvas.style.height = displaySize + 'px';

    // 실제 버퍼 크기
    canvas.width  = Math.floor(displaySize * dpr);
    canvas.height = Math.floor(displaySize * dpr);

    // CSS px 좌표계로 드로잉
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener('resize', () => { fitCanvas(); loadLevel(level); });

  // 유틸
  const key=(a,b)=>a<b?`${a}-${b}`:`${b}-${a}`;
  const shuffle=(arr)=>{for(let i=arr.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[arr[i],arr[j]]=[arr[j],arr[i]]}return arr};
  function orient(a,b,c){ return (b.x-a.x)*(c.y-a.y) - (b.y-a.y)*(c.x-a.x); }
  function onSeg(a,b,c){ return Math.min(a.x,b.x)-1e-6<=c.x&&c.x<=Math.max(a.x,b.x)+1e-6 && Math.min(a.y,b.y)-1e-6<=c.y&&c.y<=Math.max(a.y,b.y)+1e-6 && Math.abs(orient(a,b,c))<1e-6; }
  function segmentsCross(a,b,c,d){
    if((a.x===c.x&&a.y===c.y)||(a.x===d.x&&a.y===d.y)||(b.x===c.x&&b.y===c.y)||(b.x===d.x&&b.y===d.y)) return false;
    const o1=orient(a,b,c), o2=orient(a,b,d), o3=orient(c,d,a), o4=orient(c,d,b);
    if((o1===0&&onSeg(a,b,c))||(o2===0&&onSeg(a,b,d))||(o3===0&&onSeg(c,d,a))||(o4===0&&onSeg(c,d,b))) return true;
    return (o1>0)!==(o2>0) && (o3>0)!==(o4>0);
  }
  function isConnected(n,E){
    const adj=Array.from({length:n},()=>[]), seen=new Array(n).fill(false);
    for(const [u,v] of E){adj[u].push(v);adj[v].push(u)}
    let s=0; while(s<n && adj[s].length===0) s++; if(s===n) return true;
    const st=[s]; seen[s]=true; while(st.length){const x=st.pop(); for(const y of adj[x]) if(!seen[y]){seen[y]=true; st.push(y)}}
    for(let i=0;i<n;i++) if(adj[i].length>0 && !seen[i]) return false; return true;
  }
  function degrees(n,E){ const d=new Array(n).fill(0); for(const [u,v] of E){d[u]++;d[v]++} return d; }
  function oddVertices(n,E){ const d=degrees(n,E), o=[]; for(let i=0;i<n;i++) if(d[i]%2===1) o.push(i); return o; }
  function isEulerTrailGraph(n,E){ return isConnected(n,E) && ([0,2].includes(oddVertices(n,E).length)); }

  // 교차 없는(원형) 퍼즐 생성 (로직 변경 없음)
  function generateLevel(lv){
    const W = canvas.getBoundingClientRect().width; // 표시 폭 기준 (세로가 더 좁으면 fitCanvas가 폭을 이미 줄임)
    const n = Math.min(6 + Math.floor((lv-1)*0.9), 12);
    const cx=W/2, cy=W/2, r=W/2-70;

    const pts=[]; for(let i=0;i<n;i++){ const th=2*Math.PI*i/n; pts.push({x:cx+r*Math.cos(th), y:cy+r*Math.sin(th)}) }

    const Eset=new Set();
    const add=(u,v)=>{
      const k=key(u,v); if(Eset.has(k)) return false;
      for(const s of Eset){ const [a,b]=s.split('-').map(Number);
        if(a===u||a===v||b===u||b===v) continue;
        if(segmentsCross(pts[u],pts[v],pts[a],pts[b])) return false;
      }
      Eset.add(k); return true;
    };

    for(let i=0;i<n-1;i++) add(i,i+1);

    const E=()=>Array.from(Eset).map(s=>s.split('-').map(Number));
    const maxExtra=(2*n-3)-(n-1);
    const steps=Math.min(1+Math.floor(lv*0.6), Math.floor(maxExtra/2));
    let made=0, guard=0;

    while(made<steps && guard<500){
      guard++;
      const deg=degrees(n,E()), evens=[]; for(let i=0;i<n;i++) if(deg[i]%2===0) evens.push(i);
      shuffle(evens);
      let e1=null;
      for(let i=0;i<evens.length && !e1;i++) for(let j=i+1;j<evens.length && !e1;j++){
        const u=evens[i], v=evens[j]; if(Math.abs(u-v)===1||Math.abs(u-v)===n-1) continue;
        if(add(u,v)) e1=[u,v];
      }
      if(!e1) break;

      const odds=oddVertices(n,E());
      let e2=null;
      if(odds.includes(0)&&odds.includes(n-1)) { if(add(0,n-1)) e2=[0,n-1]; }
      if(!e2){
        for(let i=0;i<odds.length && !e2;i++) for(let j=i+1;j<odds.length && !e2;j++){
          const u=odds[i], v=odds[j]; if(add(u,v)) e2=[u,v];
        }
      }
      if(!e2){ Eset.delete(key(e1[0],e1[1])); break; }
      made++;
    }

    const Efinal=E(); if(!isEulerTrailGraph(n,Efinal)) return generateLevel(lv);
    return {nodes:pts, edges:Efinal};
  }

  function bindEdges(){ edgeIndexMap.clear(); edges.forEach(([a,b],i)=>edgeIndexMap.set(key(a,b),i)); }
  function draw(){
    const style = getComputedStyle(document.documentElement);
    ctx.clearRect(0,0,canvas.width,canvas.height);

    ctx.lineCap='round';
    ctx.strokeStyle= style.getPropertyValue('--edge').trim()||'#d6dee6';
    ctx.lineWidth=6;
    for(let i=0;i<edges.length;i++){
      const [a,b]=edges[i], A=nodes[a], B=nodes[b];
      ctx.beginPath(); ctx.moveTo(A.x,A.y); ctx.lineTo(B.x,B.y); ctx.stroke();
    }
    for(const i of visited){
      const [a,b]=edges[i], A=nodes[a], B=nodes[b];
      ctx.strokeStyle= style.getPropertyValue('--active').trim()||'#2563eb';
      ctx.lineWidth=10; ctx.beginPath(); ctx.moveTo(A.x,A.y); ctx.lineTo(B.x,B.y); ctx.stroke();
    }
    for(let i=0;i<nodes.length;i++){
      const p=nodes[i];
      if(i===currentNode){
        ctx.save(); ctx.shadowColor='rgba(245,158,11,.85)'; ctx.shadowBlur=24;
        ctx.beginPath(); ctx.arc(p.x,p.y,16,0,Math.PI*2); ctx.fillStyle='rgba(245,158,11,.6)'; ctx.fill(); ctx.restore();
      }
      ctx.beginPath(); ctx.arc(p.x,p.y,14,0,Math.PI*2);
      ctx.fillStyle = (i===currentNode)
        ? (getComputedStyle(document.documentElement).getPropertyValue('--nodeSel').trim()||'#f59e0b')
        : (getComputedStyle(document.documentElement).getPropertyValue('--node').trim()||'#0f172a');
      ctx.fill();
      ctx.fillStyle='white'; ctx.font='bold 12px system-ui, Arial'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(String(i+1), p.x, p.y);
    }

    const total = edges.length, done = visited.size, pct = total? Math.round(done/total*100) : 0;
    bar.style.width = pct + '%';
    hdrBar.style.width = pct + '%';
    hdrEdges.textContent = done;
    hdrTotal.textContent = total;
  }

  function getClickedNode(clientX, clientY){
    const r = canvas.getBoundingClientRect();
    const x = clientX - r.left, y = clientY - r.top;
    for(let i=0;i<nodes.length;i++) if(Math.hypot(nodes[i].x-x, nodes[i].y-y) <= 18) return i;
    return -1;
  }
  function onClick(e){
    const node = getClickedNode(e.clientX, e.clientY);
    if(node===-1) return;

    if(currentNode===null){ currentNode=node; elMsg.textContent='출발! 연결된 점으로만 이동하세요.'; draw(); return; }

    const idx = edgeIndexMap.get(key(currentNode,node));
    if(idx!==undefined && !visited.has(idx)){
      visited.add(idx); currentNode=node; elMsg.textContent='좋아요! 계속 연결하세요.'; draw();
      if(visited.size===edges.length){ canvas.removeEventListener('click', onClick); showSuccess(); }
    }else{
      canvas.classList.remove('shake'); void canvas.offsetWidth; canvas.classList.add('shake');
      elMsg.textContent='앗! 연결되지 않았거나 이미 지난 길입니다. 다시 도전!';
      resetProgress(false);
    }
  }

  function attach(){ canvas.removeEventListener('click', onClick); canvas.addEventListener('click', onClick); }
  function resetProgress(announce=true){ visited.clear(); currentNode=null; draw(); attach(); if(announce) elMsg.textContent='초기화되었습니다. 아무 점이나 눌러 시작하세요!'; }
  function loadLevel(lv){
    const g = generateLevel(lv);
    nodes=g.nodes; edges=g.edges; bindEdges();
    visited.clear(); currentNode=null;
    hdrLevel.textContent = String(lv);
    elMsg.textContent='아무 점이나 눌러 시작하세요!';
    draw(); attach();
  }
  function nextLevel(){ level++; loadLevel(level); }

  function showSuccess(){ overlay.style.display='flex'; overlay.setAttribute('aria-hidden','false'); }
  function hideSuccess(){ overlay.style.display='none'; overlay.setAttribute('aria-hidden','true'); }

  btnReset.addEventListener('click', ()=> resetProgress(true));
  btnNext .addEventListener('click', ()=> { hideSuccess(); nextLevel(); });
  btnRetry.addEventListener('click', ()=> { hideSuccess(); resetProgress(true); });
  btnGoNext.addEventListener('click', ()=> { hideSuccess(); nextLevel(); });

  fitCanvas();
  loadLevel(level);
})();
</script>
</body>
</html>
