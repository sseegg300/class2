<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover">
  <title>í•œë¶“ê·¸ë¦¬ê¸° (Euler Path) - LucyA</title>
  <style>
    :root{
      --bg: #0f1220;
      --panel: rgba(255,255,255,0.08);
      --panel2: rgba(255,255,255,0.12);
      --text: #e9edf5;
      --muted: #a8b3c7;
      --accent: #5aa2ff;
      --accent-2: #4de2b0;
      --danger: #ff6b6b;
      --ok: #66e27a;
      --shadow: 0 8px 24px rgba(0,0,0,.35);
      --radius: 16px;
    }
    *{ box-sizing: border-box; }
    html, body{ height:100%; }
    body{
      margin:0; padding: 12px 12px calc(env(safe-area-inset-bottom,0) + 12px);
      background: radial-gradient(1200px 900px at 30% -10%, #1a2142 0%, #0f1220 50%, #0b0d1a 100%);
      color: var(--text);
      font: 15px/1.6 system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans KR", sans-serif;
    }

    .wrap{
      max-width: 920px; margin: 0 auto; display: grid; gap: 12px;
      grid-template-rows: auto auto auto 1fr;
    }

    .topbar{
      display:flex; align-items:center; justify-content:space-between;
      padding: 10px 14px; border-radius: var(--radius);
      background: linear-gradient(180deg, rgba(255,255,255,.12), rgba(255,255,255,.06));
      box-shadow: var(--shadow);
      backdrop-filter: blur(6px);
    }
    .title{
      display:flex; flex-direction:column; gap: 4px;
    }
    .title h1{
      margin:0; font-size: 18px; letter-spacing:.2px;
    }
    .title .sub{
      font-size:12px; color: var(--muted);
    }
    .badge{
      display:inline-flex; align-items:center; gap:8px;
      padding:6px 10px; border-radius: 999px;
      background: var(--panel2); color: var(--muted); font-size:12px;
    }
    .badge .dot{ width:8px; height:8px; border-radius:50%; background: var(--accent); box-shadow: 0 0 14px var(--accent); }

    .stats{
      display:grid; grid-template-columns: repeat(3, 1fr); gap: 10px;
    }
    .card{
      background: var(--panel);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 12px;
    }
    .card h3{ margin:0 0 6px 0; font-size: 14px; color: var(--muted); }
    .value{ font-size: 18px; font-weight: 700; }
    .progress{
      height: 10px; background: rgba(255,255,255,.08);
      border-radius: 999px; overflow:hidden; margin-top: 6px;
    }
    .bar{ height:100%; width:0%; background: linear-gradient(90deg, var(--accent), var(--accent-2)); transition: width .2s ease; }

    .controls{
      display:flex; gap: 8px; flex-wrap: wrap;
    }
    button{
      border: 0; color: #0b0d1a; font-weight:700; cursor:pointer;
      padding:10px 14px; border-radius: 999px; transition: transform .05s ease;
      background: #fff;
    }
    button:active{ transform: translateY(1px); }
    .pill{ background: linear-gradient(180deg, #ffffff, #dfe7ff); }
    .pill.secondary{ background: linear-gradient(180deg, #d5ffe6, #b9ffd8); color:#0a2b21; }
    .pill.warn{ background: linear-gradient(180deg, #ffdfe1, #ffb5bb); color:#3a0e13; }
    .right{ margin-left:auto; }

    .stage{
      background: radial-gradient(80% 80% at 50% 0%, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 10px;
    }
    canvas{
      display:block;
      width: 100%;
      aspect-ratio: 1 / 1;                 /* í•­ìƒ ì •ì‚¬ê°í˜• ë¹„ìœ¨ */
      max-height: calc(100vh - 260px);     /* ìƒë‹¨ UI ê³ ë ¤ (í•„ìš” ì‹œ ê°’ ì¡°ì •) */
      border-radius: 16px;
      background: linear-gradient(180deg, rgba(255,255,255,.18), rgba(255,255,255,.08));
      touch-action: none; /* í„°ì¹˜ ìŠ¤í¬ë¡¤ ë°©ì§€ */
    }

    /* ìŠ¹ë¦¬ ì˜¤ë²„ë ˆì´ */
    .overlay{
      position: fixed; inset: 0; display:none;
      align-items:center; justify-content:center;
      background: rgba(0,0,0,.45); z-index: 10;
    }
    .overlay .modal{
      width: min(92vw, 460px);
      background: linear-gradient(180deg, rgba(255,255,255,.2), rgba(255,255,255,.08));
      border-radius: 18px; box-shadow: var(--shadow);
      padding: 18px;
    }
    .modal h2{ margin: 0 0 8px 0; }
    .modal p{ margin: 0 0 12px 0; color: var(--muted); }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar card" role="banner">
      <div class="title">
        <h1>ì˜¤ì¼ëŸ¬ í•œë¶“ê·¸ë¦¬ê¸° í¼ì¦</h1>
        <div class="sub">êµì°¨ ì—†ì´ ëª¨ë“  ê°„ì„ ì„ í•œ ë²ˆì”©ë§Œ ì§€ë‚˜ ì™„ì£¼í•´ ë³´ì„¸ìš”.</div>
      </div>
      <div class="badge" aria-label="signature">
        <span class="dot" aria-hidden="true"></span>
        by <strong>LucyA</strong>
      </div>
    </div>

    <div class="stats">
      <div class="card" aria-live="polite">
        <h3>ë ˆë²¨</h3>
        <div class="value" id="levelLabel">1</div>
      </div>
      <div class="card">
        <h3>ì§„í–‰</h3>
        <div class="value"><span id="visCount">0</span> / <span id="edgeCount">0</span></div>
        <div class="progress"><div class="bar" id="bar"></div></div>
      </div>
      <div class="card">
        <h3>í˜„ì¬ ë…¸ë“œ</h3>
        <div class="value" id="curNodeLabel">-</div>
      </div>
    </div>

    <div class="controls">
      <button id="resetBtn" class="pill warn">ë‹¤ì‹œ ë§Œë“¤ê¸°</button>
      <button id="sameBtn" class="pill">ì´ˆê¸°í™”(ê°™ì€ í¼ì¦)</button>
      <button id="nextBtn" class="pill secondary right">ë‹¤ìŒ ë ˆë²¨ â–¶</button>
    </div>

    <div class="stage card">
      <canvas id="board" aria-label="ê·¸ë˜í”„ í¼ì¦ ìº”ë²„ìŠ¤"></canvas>
    </div>
  </div>

  <!-- ìŠ¹ë¦¬ ëª¨ë‹¬ -->
  <div class="overlay" id="overlay" role="dialog" aria-modal="true" aria-labelledby="winTitle">
    <div class="modal">
      <h2 id="winTitle">ì„±ê³µ! ğŸ‰</h2>
      <p>ëª¨ë“  ê°„ì„ ì„ ì •í™•íˆ í•œ ë²ˆì”© ì§€ë‚¬ì–´ìš”.</p>
      <div style="display:flex; gap:8px; flex-wrap:wrap;">
        <button class="pill" id="replayBtn">ê°™ì€ ë ˆë²¨ ë‹¤ì‹œ</button>
        <button class="pill secondary" id="goNextBtn">ë‹¤ìŒ ë ˆë²¨ â–¶</button>
        <div class="right"></div>
      </div>
    </div>
  </div>

<script>
(()=>{
  const canvas = document.getElementById('board');
  const ctx = canvas.getContext('2d');

  // UI
  const levelLabel = document.getElementById('levelLabel');
  const visCountEl = document.getElementById('visCount');
  const edgeCountEl = document.getElementById('edgeCount');
  const barEl = document.getElementById('bar');
  const curNodeLabel = document.getElementById('curNodeLabel');

  const overlay = document.getElementById('overlay');
  const replayBtn = document.getElementById('replayBtn');
  const goNextBtn = document.getElementById('goNextBtn');

  const resetBtn = document.getElementById('resetBtn');
  const sameBtn  = document.getElementById('sameBtn');
  const nextBtn  = document.getElementById('nextBtn');

  // ìƒíƒœ
  let level = 1;
  let nodes = [];      // [{x,y}]
  let edges = [];      // [{a,b, visited:false}]
  let used = new Set();// key "a-b" with a<b
  let current = null;  // í˜„ì¬ ì •ì  index
  let visitedCount = 0;
  let nodeR = 10;      // í™”ë©´ í¬ê¸°ì— ë”°ë¼ ë™ì ìœ¼ë¡œ ì‚¬ìš©
  let prevCssSize = null; // ë¦¬ì‚¬ì´ì¦ˆ ì‹œ ìŠ¤ì¼€ì¼ ê³„ì‚°ìš©

  // ìœ í‹¸
  const key = (a,b)=> a<b ? `${a}-${b}` : `${b}-${a}`;
  const hasEdge = (a,b)=> used.has(key(a,b));
  const addEdge = (a,b)=>{ if(a===b || hasEdge(a,b)) return false; used.add(key(a,b)); edges.push({a,b,visited:false}); return true; };
  const neighbors = (i)=> edges.reduce((arr,e)=>{ if(e.a===i) arr.push([e.b, e]); else if(e.b===i) arr.push([e.a, e]); return arr;}, []);

  function fitCanvas(){
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const rect = canvas.getBoundingClientRect();
    // ë‚´ë¶€ ë˜ìŠ¤í„° í•´ìƒë„
    canvas.width  = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    // ë…¸ë“œ í¬ê¸°/ì„  ë‘ê»˜ ë“± í™”ë©´ ê¸°ì¤€ ë¦¬ì…‹
    nodeR = Math.max(6, Math.min(14, Math.round(rect.width / 40)));
  }

  function scaleNodesForResize(){
    const rect = canvas.getBoundingClientRect();
    if(prevCssSize == null){ prevCssSize = rect.width; return; }
    if(prevCssSize <= 0) { prevCssSize = rect.width; return; }
    const s = rect.width / prevCssSize;
    if(!isFinite(s) || s <= 0) return;
    for(let p of nodes){ p.x *= s; p.y *= s; }
    prevCssSize = rect.width;
  }

  function placeNodes(n){
    // í˜„ì¬ ìº”ë²„ìŠ¤ CSS í¬ê¸° ê¸°ì¤€ìœ¼ë¡œ ì›í˜• ë°°ì¹˜
    const rect = canvas.getBoundingClientRect();
    const cx = rect.width/2, cy = rect.height/2;
    const r = Math.min(rect.width, rect.height) * 0.40;
    nodes = [];
    for(let i=0;i<n;i++){
      const t = (Math.PI*2) * (i/n) - Math.PI/2; // ìœ„ìª½ë¶€í„° ì‹œê³„ë°©í–¥
      nodes.push({ x: cx + r*Math.cos(t), y: cy + r*Math.sin(t) });
    }
    prevCssSize = rect.width;
  }

  function makeEulerGraph(n){
    // ê¸°ë³¸ ì´ˆê¸°í™”
    edges = []; used.clear(); current = null; visitedCount = 0;

    // 1) ê¸°ë³¸ ì‚¬ì´í´ ì—°ê²°(ëª¨ë“  ì •ì  ì°¨ìˆ˜=2, ì—°ê²°ì„± í™•ë³´)
    for(let i=0;i<n;i++) addEdge(i, (i+1)%n);

    // 2) ë‚œì´ë„ ê°€ì¤‘ì„ ìœ„í•´ chord(í˜„) ì¶”ê°€ (ì§ìˆ˜ ê°œìˆ˜ë¡œ ì¶”ê°€ â†’ ì „ì²´ ì°¨ìˆ˜ ì§ìˆ˜ ìœ ì§€)
    const chordPairs = Math.min( Math.floor(n/3), 3 + Math.floor(level/2) );
    let tries = 0, added=0;
    while(added < chordPairs*2 && tries < 400){
      tries++;
      const a = Math.floor(Math.random()*n);
      let b = Math.floor(Math.random()*n);
      if(a===b) continue;
      if(hasEdge(a,b)) continue;
      // ë„ˆë¬´ ì´ì›ƒ(ì´ë¯¸ ì‚¬ì´í´ ì¸ì ‘)ì¸ ê²½ìš° íŒ¨ìŠ¤í•˜ì—¬ ê²¹ì¹¨ ê°ì†Œ
      if((a+1)%n===b || (b+1)%n===a) continue;
      if(addEdge(a,b)) added++;
    }

    // 3) 50% í™•ë¥ ë¡œ Euler "ê²½ë¡œ"(í™€ìˆ˜ 2ê°œ) ë§Œë“¤ê¸°: ì„ì˜ ê°„ì„  í•˜ë‚˜ ë” ì¶”ê°€
    if(Math.random() < 0.5){
      let count=0;
      while(count<200){
        count++;
        const a = Math.floor(Math.random()*n);
        let b = Math.floor(Math.random()*n);
        if(a===b) continue;
        if(hasEdge(a,b)) continue;
        if(addEdge(a,b)) break; // í•˜ë‚˜ë§Œ ì¶”ê°€ â†’ a,b ê°€ í™€ìˆ˜ ì°¨ìˆ˜
      }
    }

    // ê°¯ìˆ˜ í‘œê¸°
    edgeCountEl.textContent = String(edges.length);
    setProgress(0);
  }

  function setProgress(k){
    visitedCount = k;
    visCountEl.textContent = String(visitedCount);
    const p = edges.length ? Math.round((visitedCount/edges.length)*100) : 0;
    barEl.style.width = p+"%";
  }

  function draw(){
    const rect = canvas.getBoundingClientRect();
    ctx.clearRect(0,0,rect.width, rect.height);

    // ë°°ê²½ ê²©ì (ì€ì€í•˜ê²Œ)
    ctx.save();
    ctx.globalAlpha = 0.08;
    ctx.beginPath();
    const step = Math.max(24, Math.round(rect.width/14));
    for(let x=step; x<rect.width; x+=step){
      ctx.moveTo(x, 0); ctx.lineTo(x, rect.height);
    }
    for(let y=step; y<rect.height; y+=step){
      ctx.moveTo(0, y); ctx.lineTo(rect.width, y);
    }
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 1;
    ctx.stroke();
    ctx.restore();

    // ê°„ì„ 
    ctx.lineCap = 'round';
    for(const e of edges){
      const a = nodes[e.a], b = nodes[e.b];
      ctx.beginPath();
      ctx.moveTo(a.x, a.y);
      ctx.lineTo(b.x, b.y);
      ctx.lineWidth = e.visited ? Math.max(3, nodeR*0.9) : Math.max(2, nodeR*0.7);
      ctx.strokeStyle = e.visited ? '#5aa2ff' : 'rgba(255,255,255,0.45)';
      ctx.stroke();
    }

    // ë…¸ë“œ(í˜„ì¬ ê°€ëŠ¥ ì´ì›ƒ ê°•ì¡°)
    let allow = new Set();
    if(current!=null){
      for(const [nb, e] of neighbors(current)){
        if(!e.visited) allow.add(nb);
      }
    }

    for(let i=0;i<nodes.length;i++){
      const p = nodes[i];
      const isCur = (i===current);
      const isAllow = allow.has(i);
      // ì™¸ê³½ ê¸€ë¡œìš°
      ctx.beginPath();
      ctx.arc(p.x,p.y, nodeR+6, 0, Math.PI*2);
      ctx.fillStyle = isCur ? 'rgba(90,162,255,0.25)' : (isAllow ? 'rgba(77,226,176,0.22)' : 'transparent');
      ctx.fill();

      // ë³¸ì²´
      ctx.beginPath();
      ctx.arc(p.x,p.y, nodeR, 0, Math.PI*2);
      ctx.fillStyle = isCur ? '#66e27a' : (isAllow ? '#4de2b0' : '#ffffff');
      ctx.fill();
      ctx.lineWidth = 1.2;
      ctx.strokeStyle = 'rgba(0,0,0,0.35)';
      ctx.stroke();

      // ë²ˆí˜¸
      ctx.font = `bold ${Math.max(10, nodeR*0.9)}px system-ui, sans-serif`;
      ctx.fillStyle = isCur ? '#0a2b21' : '#0b0d1a';
      ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(String(i+1), p.x, p.y+0.5);
    }
  }

  // í´ë¦­/í„°ì¹˜ ì²˜ë¦¬
  function getPointerPos(evt){
    const rect = canvas.getBoundingClientRect();
    let x,y;
    if(evt.touches && evt.touches.length){
      x = evt.touches[0].clientX - rect.left;
      y = evt.touches[0].clientY - rect.top;
    }else{
      x = evt.clientX - rect.left;
      y = evt.clientY - rect.top;
    }
    return {x,y};
  }

  function findNodeAt(x,y){
    const r = nodeR * 1.4;
    for(let i=0;i<nodes.length;i++){
      const p = nodes[i];
      const dx=x-p.x, dy=y-p.y;
      if(dx*dx + dy*dy <= r*r) return i;
    }
    return -1;
  }

  function tryMove(to){
    if(current===null){
      current = to;
      curNodeLabel.textContent = String(current+1);
      draw();
      return;
    }
    if(current===to) return; // ë™ì¼ ë…¸ë“œ ë¬´ì‹œ

    // current - to ê°„ ë¯¸ì‚¬ìš© ê°„ì„ ì´ ìˆëŠ”ê°€?
    let found = null;
    for(const e of edges){
      if(e.visited) continue;
      if( (e.a===current && e.b===to) || (e.b===current && e.a===to) ){ found = e; break; }
    }
    if(!found){
      // ì˜ëª»ëœ ì´ë™ â†’ ê°€ë³ê²Œ í”ë“¤ íš¨ê³¼
      shake(canvas.parentElement);
      return;
    }

    // ì‚¬ìš© ì²˜ë¦¬
    found.visited = true;
    setProgress(visitedCount+1);

    // ìœ„ì¹˜ ì´ë™
    current = to;
    curNodeLabel.textContent = String(current+1);
    draw();

    // ì™„ë£Œ ì²´í¬
    if(visitedCount === edges.length){
      setTimeout(()=>{
        overlay.style.display='flex';
      }, 120);
    }
  }

  function shake(el){
    el.style.transition='transform .08s ease';
    el.style.transform='translateX(-5px)';
    setTimeout(()=>{ el.style.transform='translateX(5px)'; }, 90);
    setTimeout(()=>{ el.style.transform='translateX(0)'; el.style.transition=''; }, 180);
  }

  function onPointer(evt){
    evt.preventDefault();
    const {x,y} = getPointerPos(evt);
    const i = findNodeAt(x,y);
    if(i>=0) tryMove(i);
  }

  canvas.addEventListener('pointerdown', onPointer, {passive:false});
  canvas.addEventListener('click', onPointer, {passive:false});

  // ë¦¬ì‚¬ì´ì¦ˆ: í¼ì¦ ì¬ìƒì„± ì—†ì´ ì¢Œí‘œë§Œ ë¹„ë¡€ ìŠ¤ì¼€ì¼ + ë‹¤ì‹œ ê·¸ë¦¬ê¸°
  window.addEventListener('resize', ()=>{
    scaleNodesForResize();
    fitCanvas();
    draw();
  });

  // ì»¨íŠ¸ë¡¤
  resetBtn.addEventListener('click', ()=>{
    build(level); // ìƒˆ í¼ì¦ ìƒì„±
  });
  sameBtn.addEventListener('click', ()=>{
    // ê°™ì€ í¼ì¦ ì´ˆê¸°í™”(ê°„ì„  ë°©ë¬¸ë§Œ ì´ˆê¸°í™”)
    for(const e of edges) e.visited=false;
    setProgress(0);
    current = null;
    curNodeLabel.textContent = '-';
    draw();
  });
  nextBtn.addEventListener('click', ()=>{
    level++; build(level);
  });

  replayBtn.addEventListener('click', ()=>{
    overlay.style.display='none';
    build(level);
  });
  goNextBtn.addEventListener('click', ()=>{
    overlay.style.display='none';
    level++; build(level);
  });

  // ë©”ì¸ ë¹Œë“œ
  function build(lv){
    const n = Math.max(6, Math.min(14, 6 + Math.floor((lv-1)%9))); // 6~14ê°œ ì‚¬ì´ ë³€ë™
    levelLabel.textContent = String(lv);

    // ìº”ë²„ìŠ¤ ì¤€ë¹„(ë¨¼ì €)
    fitCanvas();
    // ë…¸ë“œ ë°°ì¹˜ í›„ ê·¸ë˜í”„ ìƒì„±
    placeNodes(n);
    makeEulerGraph(n);

    current = null;
    curNodeLabel.textContent = '-';
    draw();
  }

  // ì´ˆê¸° ì‹œì‘
  build(level);

})();</script>
</body>
</html>
